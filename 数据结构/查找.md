# 查找
## 概论
查找表：
查找表是由同一类型的数据元素（或记录）构成的集合  

关键字:
关键字时数据元素中某个数据项的值
若此关键字可以唯一地识别一个记录，则称此关键字为主关键字
对于那些可以识别多个数据元素（或记录）地关键字，我们称为次关键字  

查找:
查找就是根据某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）  

### 静态查找表：
只作查找操作的查找表
主要操作有：
1. 查询某个“特定的”数据元素是否在查找表中
2. 检索某个“特定的”数据元素和各种属性  

### 动态查找表：
在查找过程中同时插入查找表中不存在的数据元素，或从查找表中删除已经存在的某个数据元素
主要操作：
1. 查找时插入数据元素
2. 查找时删除数据元素  

## 顺序表查找
**顺序查找**又叫**线性查找**，是最基本的查找技术，它的查找过程是：从表中第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。 

### 顺序表查找算法
从头开始，逐一对比
代码实现：

```C
/*顺序查找，a为数组，n为要查找的数组长度，key为要查找的关键字*/
int Sequential_Search(int *a, int n, int key) {
	int i;
	for(i = 0; i <= n; i++) {
		if(a[i] == key)
			return i;
	}
	return 0;
}
```

### 顺序表查找优化
减少比较运算；从数组尾部开始循环
代码实现：
```C
/*有哨兵的顺序查找，数组中的元素从下标1开始*/
int Sequential_Search2(int *a, int n, int key) {
	int i;
	a[0] = key; //设置a[0]为关键字值，我们称为哨兵
	i = n; //循环从数组尾部开始
	while(a[i] != key) {
		i--;
	}
	return i; //返回0则查找失败
}
```

> 算法时间复杂程度：O(n)

## 有序表查找
如果线性表有序时，对查找总是很有帮助的  

### 折半查找
**折半查找**技术，又称为**二分查找**。它的前提是线性表中的记录必须是**关键码**有序（通常从小到大有序），线性表必须采用顺序储存。
折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的又搬去继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。  

代码实现：
```C
int Binary_Search(int *a, int n, int key) {
	int low, high, mid;
	low = 1; //定义最低下标为记录首位
	high = n; //定义最高下标为记录末位
	
	while(low <= high){
		mid = (low + high) / 2; //折半
		if (key < a[mid]) //若查找值比中值小
			high = mid - 1; //最高下标调整到中位下标小一位
		else if (key > a[mid]) //若查找值比中值大
			low = mid + 1; //最低下标调整到钟为下标大一位
		else
			return mid; //若相等则说明mid即为查找到的位置
	}
	
	return 0;
}
```

>算法时间复杂度：O(logn)

算法时间复杂程度分析：
首先，我们把查找过程绘制为一棵二叉树。根据二叉树的性质，“具有n个结点的完全二叉树的深度为[log2n]+1”，得到算法时间复杂程度为O(logn)  

### 插值查找
现在我们的新问题是，为什么一定要折半，而不是折四分之一或者折更多呢？  

**插值查找**是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式：
$$
\frac{key - a[low]}{a[high] - a[low]}
$$

算法思路：
折半查找代码第7行，经过略微等式变换之后得到：
$$
mid = \frac{low+high}{2} = low + \frac{1}{2}(high - low)
$$
也就是mid等于最低下标low加上最高下标high与low的差的一半。算法科学家们考虑的就是将这个1/2进行改进，改进为下面的计算方案：
$$
mid = low + \frac{key - a[low]}{a[high] - a[low]}(high - low)
$$
换句话说，我们只要将第7行代码更改为：
```C
mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]); //插值
```

### 斐波那契查找
代码实现：
```C
F[k] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …}; //斐波那契数列
int Fibonacci_Search(int *a, int n. int key) {
	int low, high, mid, i, k;
	low = 1; //定义最低下标为记录首位
	high = n; //定义最高下标为记录末位
	k = 0;
	while(n > F[k] - 1) //计算n位于斐波那契数列的位置
		k++;
	for(i = n; i < F[k] - 1; i++) { //将不满的数值补全
		a[i] = a[n];
	}
	
	while(low <= high){
		mid = low + F[k - 1] - 1; //计算当前分隔的下标
		if (key < a[mid]) { //若查找记录小于与当前年分隔记录
			high = mid - 1; //最高下标调整到分隔的下标mid - 1处
			k = k - 1; //斐波那契数列下标减一位
		}
		else if (key > a[mid]) { //若查找记录大于当前分隔记录
			low = mid + 1; //最低下标调整到分隔下标mid + 1处
			k = k - 2; //斐波那契数列下标减两位
		}
		else {
			if (mid <= n)
				return mid; //若相等则说明mid即为查找到的位置
			else
				return n; //若mid > n说明是补全数值，返回n
		}
	}
	return 0;
}
```