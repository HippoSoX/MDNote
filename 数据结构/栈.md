# 栈

## 1 栈的定义

### 1.1 栈的定义

**栈（stack）是限定仅在表尾进行插入和删除操作的线性表。**  

我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In Fist Out）的线性表，简称LIFO结构。  

理解栈的定义需要注意：

首先它是一个线性表，即它具有前驱后继的线性关系。只不过是一种特殊的线性表而已。定义中的表尾指的是栈顶。他的特殊之处就在于**限制了这个线性表的插入和删除位置，它始终只在栈顶进行，这也就使得：栈底是固定的，最先进栈的只能在栈底。**  

**栈的插入操作，叫作进栈，也称为压栈、入栈。
栈的删除操作，叫作出栈，也有叫作弹栈。**

### 1.2 进栈出栈变化形式

最先进栈的元素，就一定是最后出栈的吗？
答案是不一定的。  

栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制。我们可以来看一个例子：
现在有三个元素，分别是整型数字1，2，3，让他们依次进栈，会有那些出栈顺序呢？

>第一种：1、2、3进，再3、2、1出。这是最简单的最好理解的一种，出栈次序为321；
>
>第二种：1进，1出，2进，2出，3进，3出。也就是进一个就出一个，出栈次序为123；
>
>第三种：1进，2进，2出，1出，3进，3出。出栈次序为213；
>
>第四种：1进，1出，2进，3进，3出，2出。出栈次序为132；
>
>第五种：1进，2进，2出，3进，3出，1出。出栈次序为231。  

有没有可能是312这样的次序出栈呢？答案是肯定不会的。因为3先出栈，就意味着，3曾经进栈，既然3都进栈了，那就意味着，1和2已经进栈了，此时，2一定是在1上面的，就是更接近栈顶，那么出栈只可能是321，不然与123的进栈次序矛盾，所以此时不会发生1比2先出栈的情况。
由这个例子可以看出，出栈的次序是可以有很多变化的。这个知识点一定要弄明白。  

## 2 栈的抽象数据类型

```C
ADT 栈（strack）
Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
	InitStack(*s): 初始化操作，建立一个空栈。
	DestroyStack(*s): 若栈存在，则销毁它。
	ClearStack(*s): 将栈清空。
	StackEmpty(s): 若栈为空，返回true，否则返回false。
	GetTop(S, *e): 若栈存在且非空，用e返回s的栈顶元素。
	Push(*s, e): 若栈s存在，插入新元素e到栈s中并成为栈顶元素。
	Pop(*s, *e): 删除栈s中的栈顶元素，并用e返回其值。
	StrackLength(s): 返回栈s的元素个数。
endADT
```

## 3 栈的顺序存储结构及实现

### 3.1 栈的顺序存储结构

既然栈是线性表的特例，栈的顺序存储其实也就是线性表顺序存储的简化，简称顺序栈。线性表是用数组来实现的。  

下标为0的一端作为栈底比较好，因为首元素都在栈底，变化最小，所以让他当栈底。

我们指定一个top变量来指示栈顶元素在数组中的位置。top可以来回移动，但不能超过栈的长度。  

栈的结构定义：
```C
typedef int SElemType; /*SElemType类型根据实际情况而定，这里假设为int*/
typedef struct{
	SElemType data[MAXSIZE];
	int top; /*用于栈顶指针*/
}SqStack;
```

### 3.2 栈的顺序存储结构——进栈操作

对于栈的插入，即进栈操作push

代码实现：
```C
/*插入元素e为新的栈顶元素*/
Status Push(SqStack *s, ElemType e){
	if(s->top == MAXSIZE - 1){ /*栈满*/
		return ERROR;
	}
	s->top++; //栈顶指针增加1
	s->data[s->top] = e; //将新插入元素赋值给栈顶空间
	return OK;
}
```

### 3.3 栈的顺序存储结构——出栈操作

出栈操作pop

代码实现：
```C
/*若栈不空，则删除S的栈顶元素。用e返回其值，并返回OK；否则返回ERROR*/
Status pop(SqStack *s, SElemType *e){
	if(s->top == -1)
		return ERROR;
	*e = s->data[s->top]; //将要删除的栈顶元素赋值给e
	s->top--; //栈顶指针减1
	return OK;
}
```
>进栈和出栈的算法时间复杂度：O(1)

## 4 两栈共享空间

其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须事先确定数组存储空间的大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。
如果只是对于一个栈，我们也只能尽量考虑周全，设计初合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来操作。  

基本思想就是两栈共用一组内存空间，这样当其中一栈溢出而另一栈未满的时候，就可以充分利用未满的空间。  

我们的做法是：数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈底为数组末端，即下标为数组n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。
其关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要他俩不见面，两个栈就可以一直使用。  

栈空：当栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空。
栈满：先考虑极端情况：若栈2是空栈，栈1的top1等于n-1时，就是栈1满了；反之当栈1为空栈时，top2等于0，为栈2满。于是在一般情况下，两个栈见面时，即`top + 1 == top2`时，为栈满。  

两栈共享空间的结构的代码定义：
```C
/*两栈共享空间结构*/
typedef struct{
	SElemType data[MAXSIZE];
    int top1; //栈1栈顶指针
    int top2; //栈2栈顶指针
}SqDoubleStack;
```

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。

代码实现：
```C
/*插入元素e为新的栈顶元素*/
Status Push(SqDoubleStack *s, SElemType e, int stackNumber){
	if(s->top1+1 == s->top2) //栈已满，不能再push新元素了
		return ERROR;
	if(stackNumber == 1) //栈1有元素进栈
		s->data[++s->top1] = e; //若栈1则先top1+1后给数组元素赋值
	else if(stackNumber == 2) //栈2有元素进栈
		s->data[--s->top2] = e; //若栈2则先top2-1后给数组元素赋值
	return OK;
}
```

对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber。

代码实现：
```C
/*若栈不空，则删除s的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/
Status Pop(SqDoubleStack *s, SElemType *e, int stackNumber){
	if(stackNumber == 1){
		if(s->top1 == -1){
			return ERROR; //说明栈1已经是空栈，溢出
		}
		*e = s->data[s->top1--]; //将栈1的栈顶元素出栈
	}
	else if(stackNumber == 2){
		if(s->top2 == MAXSIZE){
			return Error; //说明栈2已经是空栈，溢出
		}
		*e = s->data[s->top2++]; //将栈2的栈顶元素出栈
	}
	return OK;
}
```

事实上，使用这样的数据结构的时候，通常都是当两个栈的空间需求有相反的关系时，也就是此消彼长的情况。这样才能比较好地利用它的特点。否则如果两个栈都在拼命增长，那样很快就栈满溢出了。
另一方面，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不同的数据类型的栈，这种方法不但不能更好地处理问题，反而会使问题变得更复杂。  

## 5 栈的链式存储结构及实现

### 5.1 栈的链式存储结构

**栈的链式存储结构，简称为链栈。**  

想想看，如果栈只是用栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须得，那么干嘛不干脆让它俩合二为一呢？所以比较好的方法是把栈顶放在单链表得头部。另外，都已经有了栈顶再头部了，单链表中比较常用得头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。  

对于链栈来说，基本不存在栈满得情况，除非内存已经没有可以使用得空间，如真的发生，恭喜你，你的计算机操作系统已经面临死机崩溃得情况，而不是这个链栈是否溢出的问题了。  

但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是`top = NULL`的时候。  

链栈的结构代码定义：
```C
typedef struct StackNode{
	SElemType data;
	struct StakNode *next;
}StackNode, *LinkStackPtr;

typedef struct LinkStack{
	LinkStackPtr top;
	int count;
}LinkStack;
```

链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些。  

### 5.2 栈的链式存储结构——进栈操作

对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针。  

代码实现：
```C
/*插入元素e为新的栈顶元素*/
Status Push(LinkStack *s, SElemType e){
	LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
	s->data = e;
	s->next = s->top; //把当前的栈顶元素赋值给新结点的直接后继
	s->top = s; //将新的结点s赋值给栈顶指针
	s->count++;
	return OK;
}
```

### 5.3 栈的链式存储结构——出栈操作

至于链栈的出栈pop操作，也是很简但的三句操作。

代码实现：
```C
/*若栈不空，则删除s的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/
Status Pop(LinkStack *s, SElemType *e){
	LinkStackPtr p;
	if(StackEmpty(*s))
		return ERROR;
	*e = s->top->data;
	p = s-top; //将栈顶结点赋值给p
	s->top = s->top->next; //使得栈顶指针下移一位，指向后一结点
	free(q); //释放结点
	s->count--;
	return OK;
}
```

>进栈和出栈的算法时间复杂度：O(1)

>对比一下顺序栈和链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要实现确定一个固定长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，**如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会好一点。**

## 6 栈的作用

栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考的范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减问题，反而掩盖了问题的本质。  

所以现在的许多高级语言，比如`Java`、`C#`等都有都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用Stack的push和pop方法，非常方便。  

## 7 栈的应用——递归

栈有一个非常重要的应用：在程序设计语言实现了递归。有一个经典的递归例子：**斐波那契数列（Fibonacci）。**  

### 7.1 斐波那契数列实现

如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔不死，那么一年后可以繁殖多少对兔子呢？  

我们拿新出生的一对小兔子分析以下：第一个月小兔子没有繁殖能力，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三队……以此类推可以列出下表：  

|所经过的月数|兔子对数|
|---|---|
|1|1|
|2|1|
|3|2|
|4|3|
|5|5|
|6|8|
|7|13|
|8|21|
|9|34|
|10|55|
|11|89|
|12|144|

表中1，1，2，3，5，8，13……构成了一个序列。这个数列有一个十分明显的特点，那是：前面两项之和，构成了后一项。  

我们用常规代码实现的迭代的方法如何实现斐波那契数列？假设我们需要建设前40位的斐波那契数列，代码实现：
```C
int main(){
	int i;
	int a[40];
	a[0] = 0;
	a[1] = 1;
	printf("%d", a[0]);
	printf("%d", a[1]);
	for(i = 2; i < 40; i++){
		a[i] = a[i - 1] + a[i - 2];
		printf("%d", a[i]);
	}
	return 0;
}
```

代码很简单，但其实我们用递归来实现更简单，
代码实现：
```C
/* 斐波那契数列的递归函数 */
int Fbi(int i){
	if(i < 2)
	return i == 0 ? 0 : 1;
return Fbi(i - 1) + Fbi(i - 2);/* 递归 */
}

int main(){
	int i;
	for(int i = 0; i < 40; i++){
		print("%d", Fbi(i));
	}
	return 0;
}
```

### 7.2 递归定义

在高级语言中，调动自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。  

当然，写程序最怕的就是陷入永不结束的无穷递归中，所以，**每个递归定义必须要有一个条件，满足时递归不在进行，即不在调用自身而是返回值退出。**  

>对比两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少了读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量时间和内存。迭代则不需要反复调用函数和占用额外内存。因此我们应该视不同情况选择不同的代码实现方式。

函数栈略。

## 8 栈的应用——四则运算表达式求值

栈的现实应用也有很多，我们再来重点讲一个比较常见的应用：**数学表达式的求值。**

### 8.1 后缀（逆波兰）表示法定义

我们在学四则运算的时候，所学到的运算法则，用口诀记住就是：先乘除，后加减，从左到右，先算括号内的再算括号外的。  

那如果要用C语言，要怎么实现呢？四则运算法则与C语言语法矛盾的地方在于，乘除在加减的后面，但要先运算。而加入了括号，就更复杂了。那要如何处理呢？  

仔细分析一下。首先，括号都是成对出现的，就算是嵌套使用，左右括号也一定是匹配的。这用栈结构正好适合，只要碰到左括号，就将此左括号进栈，不管表达式有多少重括号，而后面遇到右括号时，就让栈顶的左括号出栈，期间让数字运算。这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空元素到有元素，最终在因全部匹配成功后成为空栈。  

但对于四则运算，括号也只是u其中的一部分，先乘除后加减使得问题依然复杂，如何有效地处理它们呢？  
20世纪50年代，波兰逻辑学家Jan Lukasiewicz提出了一种不需要括号的后缀表达法，我们也把它称为逆波兰（Reverse Polish Notation，RPN）表示。这种后缀表达式，是表达式的一种新的显示方式，非常巧妙地解决了程序实现四则运算的难题。  

举个例子，对于“9+(3-1)×3+10÷2”，如果要用后缀表示法应该是什么样子：“9 3 1 - 3 * + 10 2 / +”，这样的表达式称为**后缀表达式**，叫后缀的原因在于**所有的符号都是在要运算数字的后面出现**。  

### 8.2 后缀表达式计算结果

为了解释后缀表达式的好处，我们先来看看，计算机如何应用后缀表达式计算出最终的结果20的。  

后缀表达式：9 3 1 - 3 * + 10 2 / +  

规则：从左到右遍历表达式的每个数字和符号。遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。
1. 初始化一个空栈。此栈用来对要运算的数字进出使用。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0| |
2. 后缀表达式中前三个都是数字，所以931进栈。
|4| |
|---|---|
|3| |
|(top)2|1|
|1|3|
|0|9|
3. 接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈。
|4| |
|---|---|
|3| |
|2| |
|(top)1|2|
|0|9|
4. 接着是数字3进栈。
|4| |
|---|---|
|3| |
|(top)2|3|
|1|2|
|0|9|
5. 后面是“\*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈。
|4| |
|---|---|
|3| |
|2| |
|(top)1|6|
|0|9|
6. 下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0|15|
7. 接着是10与2两数字进栈。
|4| |
|---|---|
|3| |
|(top)2|2|
|1|10|
|0|15|
8. 接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。
|4| |
|---|---|
|3| |
|2| |
|(top)1|5|
|0|15|
9. 最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0|20|
10. 结果是20出栈，栈变为空。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0| |

后缀表达式可以很顺利地解决计算的问题，那么这个后缀表达式又是怎么来的呢？

### 8.3 中缀表达式转后缀表达式

平时所用的标准四则运算表达式，即“9+(3-1)×3+10÷2”叫作**中缀表达式**。

中缀表达式** “9+(3-1)×3+10÷2” **转化为后缀表达式** “9 3 1 - 3 * + 10 2 / +” **。

这就是我们现在要解决的问题。  

规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。  

1. 初始化一空栈，用来对符号进出栈使用。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0| |
输出：无

2. 第一个字符数字9，输出9，后面是符号“+”，进栈。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0|+|
输出：9

3. 第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈.
|4| |
|---|---|
|3| |
|2| |
|(top)1|(|
|0|+|
输出：9

4. 第四个字符是数字3，输出，总表达式为9 3，接着是“-”，进栈。
|4| |
|---|---|
|3| |
|(top)2|-|
|1|(|
|0|+|
输出：9 3

5. 接下来是数字1，输出，总表达式为9 3 1，后面是符号")"，此时，我们需要去匹配此前的的"("，所以栈顶依次出栈，并输出，直到"("出栈为止。此时左括号上方只有”-“，因此输出"-"。总的输出表达式为9 3 1 - 。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0|+|
输出：9 3 1 -

6. 紧接着是符号”×“，因为此时栈顶符号为"+"号，优先级低于”×“，因此不输出，”\*“进栈。紧接着是数字3，输出，总的表达式为9 3 1 - 3。
|4| |
|---|---|
|3| |
|2| |
|(top)1|\*|
|0|+|
输出：9 3 1 - 3

7. 之后是符号”+“，此时当前栈顶元素”\*“比这个”+“的优先级高，因此栈中元素出栈并输出（并没有比”+“号更低的优先级，所以全部出栈），总输出表达式为9 3 1 - 3 \* +。然后将当前这个”+“进栈。也就是说，前六张表中栈底的“+”是指中缀表达式中开头的9后面那个”+“，而此时栈底的”+“是最后一个”+“。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0|+|
输出：9 3 1 - 3 \* +

8. 紧接着数字10，输出，总表达式变为9 3 1 - 3 \* + 10，后是符号”÷“，所以”/“进栈。
|4| |
|---|---|
|3| |
|2| |
|(top)1|/|
|0|+|
输出：9 3 1 - 3 \* + 10

9. 最后一个数字2，输出，总的表达式为9 3 1 - 3 \* + 10 2。
|4| |
|---|---|
|3| |
|2| |
|(top)1|/|
|0|+|
输出：9 3 1 - 3 \* + 10 2

10. 因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为9 3 1 - 3 \* + 10 2 / +。
|4| |
|---|---|
|3| |
|2| |
|1| |
|(top)0| |
输出：9 3 1 - 3 \* + 10 2 / +

>想要计算机处理我们通常的四则运算表达式，最重要的两步：
>1. 将中缀表达式转化为后缀表达式（栈用来进出运算的符号）
>2. 将后缀表达式进行运算得出结果（栈用来进出运算的数字）

整个过程，都充分利用了栈的后进先出特性来处理，理解好了它其实也就理解好了栈这个数据结构。

## 9 队列的定义

**队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。**  

队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。  

队列在程序设计中用的非常频繁。比如电脑记录你的鼠标键盘操作，电话客服排队等。  

## 10 队列的抽象数据类型

```C
ADT 队列（Queue）
Data
	同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
	InitQueue(*Q)：初始化操作，建立一个空队列Q。
	DestroyQueue(*Q)：若队列Q存在，则销毁它。
	ClearQueue(*Q)：将队列Q清空。
	QueueEmpty(Q)：若队列Q为空，则返回true，否则返回false。
	GetHead(Q,*e)：若队列Q存在且非空，用e返回队列Q的队头元素。
	EnQueue(*Q,e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
	DeQueue(*Q,*e)：删除队列Q中队头元素，并用e返回其值。
	QueueLength(Q)：返回队列Q的元素个数。
endADT
```

## 11 循环队列

线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。

### 11.1 队列顺序存储的不足

我们假设一个队列有n个元素，则顺序存储的队列需要建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)。  

与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为O(n)。  

这里的实现和线性表的顺序存储结构完全相同，不再详述。  

而其实想想，为什么出队列一定要全部移动呢？如果不去限制队列的元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定要在下标为0的位置。
为了避免当只有一个元素时，队头和队尾重合导致处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。  

然而这就有问题产生了。当数组的最后一个元素填满时，此时rear指针将指向数组外面。访问数组外面的未定义内存是很危险的。另一方面，假设这个队列的总个数不超过5个，目前已经入队的元素分别占据了数组下标2，3，4的位置，总共3个元素，队列还没有满，但目前如果接着入队的话，因为数组末尾元素已经占用了，再向后加，就会发生数组越界的错误，可实际上，数组下标0，1位置是空的。我们擦这种现象叫作”假溢出“。  

怎么解决这些问题？

### 11.2 循环队列定义

解决假溢出的方法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种**头尾相接的顺序存储结构称为循环队列**。  

接着刚才的例子，rear可以改为指向下标为0的位置，这样就不会造成指针指向不明的问题了。接着入队第6个元素，将其置于下标0的位置，rear指向下标为1的位置。若再入队第7个元素，rear就和front指针重合，同时指向下标为2的位置。  

此时问题又来了，我们刚才说，空队列时，是front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？

+ 办法一是设置一个标志变量flag，当front == rear，且flag == 0时队列为空，当front == rear， flag = 1时为队列满。
+ 办法二是当队列空时，条件就是front == rear，当队列满时，我们修改条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元，我们就认为此队列已经满了。这样会浪费一个位置的空间，但是会避免两个指针指向同一个位置的情况发生。

我们来重点讨论第二种方法。由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+ 1) % QueueSize == front（取模%是为了整合rear和front大小为一个问题）。
另外，当rear > front时，此时队列的长度为rear - front。但当rear < front时，队列长度分为两段，一段是QueueSize - front，另一段是0 + rear，加在一起，队列长度为rear - front + QueueSize。**因此通用计算队列长度公式为
(rear - front + QueueSize) % QueueSize**

接下来是代码定义：
```C
typedef int QELemType;//QELemType类型根据实际情况而定，这里假设是int
typedef struct{
	QElemType data[MAXSIZE];
	int fornt; //头指针
	int rear; //尾指针，若队列不空，指向队列尾部元素的下一个位置
}SqQueue;
```
循环队列的初始化代码如下：
```C
/* 初始化一个空队列Q */
Status InitQueue(SqQueue *Q){
	Q->front = 0;
	Q->rear = 0;
	return OK;
}
```

循环队列求队列长度代码如下：
```C
/* 返回Q的元素个数，也就是队列的当前长度 */
int QueueLength(SqQueue){
	return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
```

循环队列的入队操作代码如下：
```C
/* 若队列未满，则插入元素e为Q的新的队尾元素 */
Status EnQueue(SqQueue *Q, QElemType e){
	if((Q->rear + 1) % MAXSIZE == Q->front){
	//队列满的判断
		return ERROR;
	}
	Q->data[Q->rear] = e; //将元素e赋值给队尾
	Q->rear = (Q->rear + 1) % MAXSIZE; //rear指针指向后移一位，若到最后则转到数组头部
	return OK;
}
```

循环队列的出队列操作代码如下：
```C
/* 若队列不空，则删除Q中队头元素，用e返回其值 */
Status DeQueue(SqQueue *Q, QElemType *e){
	if(Q->front == Q->rear) {
	//队列空的判断
		return ERROR;
	}
	*e = Q->data[Q->front]; //将队头元素赋值给e
	Q->front = (Q->front + 1) % MAXSIZE; //front指针向后移一位，若到最后则转到数组头部
	return OK;
}
```
## 13 队列的链式存储结构及实现

**队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。**为了操作上的方便，我们将队头指针指向链队列的头结点，，而队尾指针指向终端结点。  

空队列是，front和rear都指向头结点。  

链队列的代码定义：
```C
typedef int QElemType; //QElemType类型根据实际情况而定，这里假设为int
typedef struct QNode { //结点结构
	QElemType data;
	struct QNode *next;
}QNode, *QueuePtr;

typedef struct { //队列的链表结构
	QueuePtr front, rear; //队头、队尾指针
}LinkQueue;
```

### 13.1 队列的链式存储结构——入队操作

代码实现：
```C
/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q, QElemType e) {
	QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
	if(!s) //存储分配失败
		exit(OVERFLOW);
	s->data = e;
	s->next = NULL;
	Q->rear->next = s; //把拥有元素e新结点s赋值给元队尾结点的后继
	Q->rear = s; //把当前的s设置为对尾结点，rear指向s
	return OK;
}
```

### 13.2 队列的链式存储结构——出队操作

代码实现：
```C
/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR */
Status DeQueu(LinkQueue *Q, QElemType *e) {
	QueuePtr p;
	if(Q->fornt == Q->rear) {
		return ERROR;
	}
	p = Q->front->next; //将欲删除的队头结点暂存给p
	*e = p->data; //将欲删除的队头结点的值赋值给e
	Q->front->next = p->next; //将原队头结点后继p->next赋值给头结点后继
	if(Q->rear == p){ //若队头是队尾，则删除后将rear指向头结点
		Q->rear = Q->front;
	}
	free(p);
	return OK;
}
```

>对于循环队列和链队列比较，可以从两方面来比较。从时间上，其实两者都是O(1)的，不过循环队列是事前先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差别。从空间上来讲，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。在空间上，链队列明显要更加灵活。