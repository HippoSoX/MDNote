# 串

## 1 串的定义

**串（string）是由零个或多个字符组成的有限序列，又名叫字符串。**一般记为s = “a1a2……an”(n>=0)。串中的**字符数目n称为串的长度**，定义中谈到“有限“是指长度n是一个有限的数值。零个字符的串称为**空串(null string)**，它的长度为零，可以直接用两双引号**""**表示。所谓的**序列**，说明串的相邻字符之间具有前驱和后继的关系。  

**空格串**，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。  

**子串与主串**，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含字串的串称为主串。子串在主串中的位置就是子串的第一个字符在主串中的序号。  

## 2 串的比较

两个字符串比较大小是利用其**编码**的值来进行比较的，其编码值的大小取决于它们每个字母的前后顺序。  
计算机中常用的字符是使用标准的**ASCII编码**，其他常用编码包括**Unicode**、中文编码GB、BIG5等。  

所以在c语言中比较两个串是否相等，必须是两个串的长度以及它们各个位置对应的字符都要相等时，才算是相等。  

那对于两个串不相等，时，如何判定其大小呢？
给定两个串：s = ”a1a2……an“，t = ”b1b2……bn“，当满足下列条件之一时，s < t。
1. n<m，且ai = bi (i = 1, 2, ……，n)
2. 存在某个k <= min(m, n)，使得ai = bi (i = 1, 2, ……, k - 1)，ak < bk。  

## 3 串的抽象数据类型

串的结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符，哪怕是串中字符是”123“这样的数字组成，或者是”2010-10-10“这样的日期组成，它们都只能理解为长度为3和长度为10的字符串，每个元素都是字符而已。  

因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串的位置、得到指定位置子串、替换子串等操作。  

代码定义：
```C
ADT 串(string)
data 
	串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
	StrAssign(T, *chars): 生成一个其值等于字符串常量的chars的串T
	StrCopy(T, S): 串S存在，由串S复制的串T。
	ClearString(S): 串S存在，将串清空。
	StringEmpty(S): 若串S为空，返回true，否则返回false。
	StrLength(S): 返回串S的元素个数，即串的长度。
	StrCompare(S, T): 若S>T，返回值>0；若S=T，返回0；若S<T，返回值<0。
	Concat(T, S1, S2): 用T返回由S1和S2联接而成的新串。
	SubString(Sub, S, pos, len): 串S存在，1 ≤ pos ≤ StrLength(S)，且0 ≤ len ≤ [StrLength(S) - pos + 1]，用Sub返回串S的第pos个字符起长度为len的子串。
	Index(S, T, pos): 串S和T存在，T是非空串，1 ≤ pos ≤ StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串中第pos个字符后第一次出现的位置，否则返回0。
	Replace(S, T, V): 串S、T和V存在，T是非空串。用V替换主串中出现的所有与T相等的不重叠的子串。
	StrInsert(S, pos, T): 串S和T存在，1 ≤ pos ≤ [StrLength(S) + 1]。在串S的第pos个字符之前插入串T。
	StrDelete(S, pos, len): 串S存在，1 ≤ pos ≤ [StrLength(S) - len + 1]。从串S中删除第pos个字符起长度为len的子串。
endADT
```

对于不同的高级语言，其实对串的基本操作会有不同的定义方法。  

来看一个操作Index的实现算法。
代码实现：
```C
/* T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0。 */
int Index(String S, String T, int pos) {
	int n, m, i;
	String sub;
	if(pos > 0) {
		n = StrLength(S); //得到主串S的长度
		m = StrLength(T); //得到子串T的长度
		i = pos;
		while(i <= n - m + 1) {
			SubString(sub, S, i, m); //取主串第i个位置，长度与T相等子串给sub
			if(StrCompare(sub, T) != 0) { //若两串不相等
			++i;
			}
			else { //若两串相等
				return i; //则返回i值
			}
		}
	}
	return 0; //若无子串与T相等，返回0
}
```

## 4 串的存储结构

串的存储结构与线性表相同，分为两种。  

### 4.1 串的顺序存储结构

串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。  按照预定义的大小，为每个定义的串变量分配一个固定的长度的存储区。一般是用定长数组来定义。  

既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\0"来表示串值的终结，这个时候，你想要知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间。  

刚才讲的串的顺序存储方式其实是有有问题的，因为字符串的操作，比如两串的连接Concat、新串的插入StrInsert、以及字符串的替换Replace，都有可能使得串序列的长度炒股了数组的长度MaxSize。  

于是对于串的顺序存储，有一些变化，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫作“堆”。这个堆可由C语言的动态分配函数`malloc()`和`free()`来管理。  

### 4.2 串的链式存储结构

对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用”#“或其他非串字符补全。当然，这里一个结点存在多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。  

但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。  

## 5 朴素的模式匹配算法

**子串的定位操作通常称做串的模式匹配**，应该算是串中最重要的操作之一。假设我们要从下面的主串**S=”goodgoogle“**，找到**T=”google“**这个子串的位置。我们通常需要下面的步骤。  

1. 主串S第一位开始，S与T前三个都匹配成功，但S第四个字母是d而T的是g。第一位匹配失败。
|g|=|g|
|-|-|-|
|o|=|o|
|o|=|o|
|g|/|d|
|l||g|
|e||o|
|||o|
|||g|
|||l|
|||e|

2. 主串S第二位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败。
|||g|
|-|-|-|
|g|/|o|
|o||o|
|o||d|
|g||g|
|l||o|
|e||o|
|||g|
|||l|
|||e|

3. 主串S第三位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败。
|||g|
|-|-|-|
|||o|
|g||o|
|o||d|
|o||g|
|g||o|
|l||o|
|e||g|
|||l|
|||e|

4. 主串S第四位开始，主串S首字母是g，匹配失败。
|||g|
|-|-|-|
|||o|
|||o|
|g|\|d|
|o||g|
|o||o|
|g||o|
|l||g|
|e||l|
|||e|

5. 主串S第五位开始，S与T，6个字母全匹配，匹配成功。
|||g|
|-|-|-|
|||o|
|||o|
|||d|
|g|=|g|
|o|=|o|
|o|=|o|
|g|=|g|
|l|=|l|
|e|=|e|

简单来说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。  

前面我们已经用串的其他操作实现了模式匹配的算法Index。现在不用串的其他操作，而是只用基本数组来实现同样的算法。注意我们假设主串S和要匹配的子串T的长度存在S[0]与T[0]中。
代码实现：
```C
/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/* T非空，1 ≤ pos ≤ StrLength(S)。 */
int Index(String S, String T, int pos){
	int i = pos;
	int j = 1;
	while(i <= S[0] && j <= T[0]) {
		if (S[i] == T[j]) {
			++i;
			++j;
		}
		else {
			i = i - j + 2;
            j = 1;
		}
	}
	if (j > T[0]) {
		return i - T[0];
	}
	else {
		return 0;
	}
}
```

分析一下，最好的情况是什么？那就是一开始就匹配成功了，时间复杂度为O(1)。稍差一点，如果每次都是首字母不匹配，那么对T串的循环就不用进行了，那么时间复杂度为O(n+m)，其中n为主串长度，m为要匹配的子串长度。根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。  

那么最坏的情况是什么呢？就是每次不陈公公的匹配都是在串T的最后一个字符。举一个很极端的例子，S=”000000000000000000000000000000000000001“，T=”000001“。这样在匹配时，每次都得将T中字符循环到最后一位才发现：哦，原来他们是不匹配的。这样等于T串需要在S串的前(n-m+1)个位置都判断m次，并得出不能匹配的结果。直到最后第n-m的位置，因为全部匹配相等，所以不用再进行下去。或者说，此时的T仍然没有成功匹配，依然不需要继续匹配下去。因此最坏的情况就是时间复杂度为O((n-m+1)\*m)。  

>时间复杂度为O((n-m+1)\*m) 

## 6 KMP模式匹配算

KMP模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特——莫里斯——普拉特算法，简称KMP算法。

### 6.1 KMP匹配算法原理






